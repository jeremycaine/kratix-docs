---
title: Backstage Plugins
description: Documentation for the enterprise plugins for Backstage bundled with SKE.
sidebar_label: Backstage Plugins
---

The Backstage plugins for SKE are a set of plugins that are to provide additional
functionality to Backstage. The plugins are:

- `@syntasso/plugin-ske-backend`: The backend plugin for SKE.
- `@syntasso/plugin-ske-frontend`: The frontend plugin for SKE.

Follow the instructions below to install and configure both plugins.

The instructions below assume that you have created a Backstage app. The
commands must be executed from the root of your Backstage app. Refer to the
[Backstage official documentation](https://backstage.io/docs/getting-started)
for instructions on how to create a Backstage app.

:::info

For the plugins to work, make sure you have the following environment variable set when
starting your Backstage app:

```bash
export NODE_OPTIONS=--no-node-snapshot
```

:::

## Accessing the private npm registry

### For local development {#local-development}

To access the private npm registry in your local machine, you will need npm config in a
local `~/.npmrc` file in your home directory. Create this file if it doesn't already
exist, and add the following content:

```bash
# replace <YOUR_TOKEN_HERE> with the provided token
@syntasso:registry=https://npm.pkg.github.com
//npm.pkg.github.com/:_authToken="<YOUR_TOKEN_HERE>"
always-auth=true
```

:::info

For Yarn 3+, use the following command to set a local `.yarnrc.yml` file:

```bash
export PRIVATE_REGISTRY_TOKEN="<YOUR_TOKEN_HERE>"

yarn config set npmScopes --json '{"syntasso": {"npmAlwaysAuth": true, "npmAuthToken": "$PRIVATE_REGISTRY_TOKEN", "npmRegistryServer": "https://npm.pkg.github.com"}}'
```

:::

### For Docker

For Docker builds, you must update the `packages/backend/Dockerfile` in your Backstage
app so that it can access the private npm registry.

Update the `RUN` command that is running the `yarn install` to mount a secret, as
described below:

```Dockerfile
RUN --mount=type=cache,target=/home/node/.cache/yarn,sharing=locked,uid=1000,gid=1000 \
    #highlight-next-line
    --mount=type=secret,id=npmrc,target=/app/.npmrc,uid=1000,gid=1000 \
    yarn install --frozen-lockfile --production --network-timeout 300000
```

When running `yarn build-image` you now need to pass in the additional args
`--secret id=npmrc,src=$HOME/.npmrc` to provide the npm credentials to Docker.
Alternatively, you can update the `build-image` script in the `package.json`
file to include the additional required flag.

:::warning

Make sure that the `~/.npmrc` file is in the home directory of the user that is running
the Docker build. Refer to the [Local Development](#local-development) section for instructions.

:::

## Installing the front-end plugin

From the root of the backstage repository, run:

```bash
yarn add @syntasso/plugin-ske-frontend --cwd packages/app
```

### Update the EntityPage

In the `packages/app/src/components/catalog/EntityPage.tsx` file, add the following to the list of imports:

```typescript
import { KratixPromiseEntityPage, KratixResourceEntityPage } from '@syntasso/plugin-ske-frontend';
```

Find the line where the `const componentPage` is being declared. Add the following case
to the `EntitySwitch`:

```typescript
<EntitySwitch.Case if={isComponentType('kratix-promise')}>
  <KratixPromiseEntityPage>{entityWarningContent}</KratixPromiseEntityPage>
</EntitySwitch.Case>

<EntitySwitch.Case if={isComponentType('kratix-resource')}>
  <KratixResourceEntityPage>{entityWarningContent}</KratixResourceEntityPage>
</EntitySwitch.Case>
```

When updated, the `componentPage` variable should look similar to this, with any other
additional case statements:

```typescript
const componentPage = (
  <EntitySwitch>
    <EntitySwitch.Case if={isComponentType("service")}>
      {serviceEntityPage}
    </EntitySwitch.Case>

    <EntitySwitch.Case if={isComponentType("website")}>
      {websiteEntityPage}
    </EntitySwitch.Case>

    //highlight-start
    <EntitySwitch.Case if={isComponentType('kratix-promise')}>
      <KratixPromiseEntityPage>{entityWarningContent}</KratixPromiseEntityPage>
    </EntitySwitch.Case>

    <EntitySwitch.Case if={isComponentType('kratix-resource')}>
      <KratixResourceEntityPage>{entityWarningContent}</KratixResourceEntityPage>
    </EntitySwitch.Case>
    //highlight-end

    <EntitySwitch.Case>{defaultEntityPage}</EntitySwitch.Case>
  </EntitySwitch>
);
```

## Installing the back-end plugin

From the root of the backstage repository, run:

```bash
yarn add @syntasso/plugin-ske-backend --cwd packages/backend
```

### Configure

Add the following to the `app-config.yaml` file:

```yaml
ske:
  scm:
    type: "github" # or "gitlab"
    token: "my-access-token" # github/gitlab access token
    repoUrl: "https://github.com/my-org/my-repo" # repository url
    path: "resources" # optional; path within the repository
    branch: "main" # optional; branch to use, default is "main"
```

The `repoUrl` is the repository to which Backstage will push the resource
requests; you must configure your platform to reconcile on new documents.

### Add the backend route

Open the `packages/backend/src/index.ts` file and add the following import:

```typescript
import { createRouter } from "@syntasso/plugin-ske-backend";
```

Then in the `main()` function, add the following near the other endpoints in the `apiRouter`:

```typescript
// in the main function...
apiRouter.use("/techdocs", await techdocs(techdocsEnv));
apiRouter.use("/proxy", await proxy(proxyEnv));
apiRouter.use("/search", await search(searchEnv));

//highlight-start
const { logger } = createEnv("ske");
apiRouter.use("/ske", await createRouter({ logger, config }));
//highlight-end
// ...
```

### Add the scaffolder action

Open the `packages/backend/src/plugins/scaffolder.ts` file and add the SKE actions. Your
`scaffolder.ts` should look something like this:

```typescript
import { CatalogClient } from "@backstage/catalog-client";
import {
  createBuiltinActions,
  createRouter,
} from "@backstage/plugin-scaffolder-backend";
import { Router } from "express";
import type { PluginEnvironment } from "../types";
import { ScmIntegrations } from "@backstage/integration";

//highlight-start
// Import skeActions
import { skeActions } from "@syntasso/plugin-ske-backend";
//highlight-end

export default async function createPlugin(
  env: PluginEnvironment
): Promise<Router> {
  const catalogClient = new CatalogClient({
    discoveryApi: env.discovery,
  });

  /* To preserve the builtin actions, do the following */
  const integrations = ScmIntegrations.fromConfig(env.config);
  const builtInActions = createBuiltinActions({
    catalogClient,
    integrations,
    config: env.config,
    reader: env.reader,
  });

  //highlight-start
  const actions = [
    ...skeActions({ integrations, config: env.config }),
    ...builtInActions,
  ];
  //highlight-end

  return await createRouter({
    logger: env.logger,
    config: env.config,
    database: env.database,
    reader: env.reader,
    catalogClient,
    identity: env.identity,
    permissions: env.permissions,
    //highlight-next-line
    actions, // <-- add this line
  });
}
```

:::tip

If you are adding the plugin to a new Backstage app (or if you have not modified
the `scaffolder.ts` file previously), you can just copy and paste the entire
snippet below.

:::

Once both packages are added and configured, from the root of your Backstage app, run:

```bash
yarn install
```

Your backstage instance is now ready to use the SKE plugins.

## Using the actions

Once both your front-end and back-end plugins are installed and configured, your
backstage should now have the SKE actions available and it should be able to render
Kratix resources in the catalog.

To access the documentation for the SKE actions, check the actions documentation
on your Backstage instance, which is available on the `/create/actions`
endpoint.

### Example: Using the `ske:configure-resource` action in a Template

The `ske:configure-resource` action works by pushing a generated Resource Request manifest
to a Git repository, and can be used in a Template to make these requests from within
Backstage. The Template allows all Promise API fields to be filled in within Backstage.

An outline of a Template for generating Jenkins Resource Requests is as follows:

```yaml
apiVersion: scaffolder.backstage.io/v1beta3
kind: Template
metadata:
  description: Jenkins as a Service
  name: jenkins-promise-template
  title: Jenkins
spec:
  lifecycle: experimental
  owner: kratix-platform
  parameters:
  - properties:
      objname:
        description: Name for the request in the platform cluster
        title: Name
        type: string
      objnamespace:
        description: Namespace for the request in the platform cluster
        title: Namespace
        type: string
    required:
    - objname
    - objnamespace
    title: Jenkins Instance Metadata
  # other properties can be added here
  steps:
  - action: ske:configure-resource
    id: ske-configure-resource
    input:
      manifest: |
        apiVersion: marketplace.kratix.io/v1alpha1
        kind: jenkins
        metadata:
          name: ${{ parameters.objname }}
          namespace: ${{ parameters.objnamespace}}
        spec: ${{ parameters.spec | dump }}
    name: Create a Jenkins
  type: kratix-resource
```

## The Kratix Catalog Entities

The front-end plugin provides specific entity pages for both Kratix Promises and Kratix
Resources. To get all features of the plugin, your Components must include a few fields
and annotations so that the front-end plugin can render the right data.

### Kratix Promise Entity

Kratix Promises should be created with `type: "kratix-promise"` and a set of `kratix.io/`
annotations which are used to convey metadata to the front-end plugin. The name, title
and description should also be set to appropriate values.

For example, considering a Promise that provides a Jenkins resource, the Component
definition would look like this:

```yaml
apiVersion: backstage.io/v1alpha1
kind: Component
metadata:
  #highlight-start
  name: jenkins-promise # Name of the Promise Component
  title: Jenkins Promise # Title to be displayed in Backstage
  description: Jenkins as a Service # Description of the Promise
  annotations:
    kratix.io/promise-name: cicd # The Promise's metadata.name
    kratix.io/api-name: Jenkins # The Kind of the resource provided by the Promise
    kratix.io/api-group: marketplace.kratix.io # The Group of the resource provided by the Promise
    kratix.io/status: |
      {"message": "Some Status Message"}
    kratix.io/backstage-promise-template: jenkins-promise-template # metadata.name of the Backstage Template used to create the resource
  #highlight-end
spec:
  # highlight-next-line
  type: kratix-promise
  # remainder of the component spec...
```

### Kratix Resource Entity

Kratix Resources should be created with `type: "kratix-resource"` and a set of `kratix.io/`
annotations which are used to convey metadata to the front-end plugin. The name, title
and description should also be set to appropriate values.

The relationship between the Resource and the Promise can be displayed in the front-end
plugin by adding a [`dependsOn` relation](https://backstage.io/docs/features/software-catalog/well-known-relations/#dependson-and-dependencyof)
to the spec, which references the Promise Component via an
[entity reference](https://backstage.io/docs/features/software-catalog/references#string-references).

For example, considering a Jenkins resource requested on the Promise shown above, the
Component definition for the Jenkins resource would look like this:

```yaml
apiVersion: backstage.io/v1alpha1
kind: Component
metadata:
  #highlight-start
  name: my-request-jenkins # Name of the Resource Component
  title: "my-request Jenkins" # Title to be displayed in Backstage
  description: "my-request Jenkins created via cicd Promise" # Description of the resource
  annotations:
    kratix.io/status: |
      {"message": "Some Status Message"}
    kratix.io/promise-name: cicd # The Jenkins Promise's metadata.name
    kratix.io/group: "marketplace.example.io" # Promise API Group
    kratix.io/version: "v1alpha1" # Promise API Version
    kratix.io/kind: Jenkins # Promise API Kind
    kratix.io/name: my-jenkins # Name of the Resource
    kratix.io/namespace: default # Namespace of the Resource
    kratix.io/backstage-promise-template: jenkins-promise-template # metadata.name of the Backstage Template used to create the resource
  #highlight-end
spec:
  #highlight-start
  type: kratix-resource
  dependsOn:
    - component:default/jenkins-promise # Entity reference for the Promise Component
  #highlight-end
  # remainder of the component spec...
```
