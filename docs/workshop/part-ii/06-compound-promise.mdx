---
id: compound-promise
title: Making a Compound Promise
description: Extend the app promise with a database option, making it a compound promise
---
```mdx-code-block
import CodeBlock from '@theme/CodeBlock';
```

This is Part 2 of [a series](intro) illustrating how Kratix works. <br />
üëàüèæ&nbsp;&nbsp; Previous: [Updating the Resource status](updating-status)<br />
üëâüèæ&nbsp;&nbsp; Next: [What's next](whats-next)

<hr />

In the previous section, you learned how the update the status of a resource request. This allowed you to equip the user with relevant information about their request, in this case, the url of their todo app.

In this section, you will gain an understanding of Compound Promises. You will:

- [Configure a Compound Promises](#)
- [Learn how to use Destination Selectors in your pipeline](#)

At present, users can self-serve their own App-as-a-Service but we know that eventually users will need a way to persist the state of their applications. A database is another offering that can be provided As-a-Service to users, providing platform teams with control over where the services are deployed. As, in this case, the need for a database is tied to the functionality of the App-as-a-Service, we can make the Database platform offering something that can requested alongside the App-as-a-service.

To achieve this, we will make it possible for users to request a Postgresql service alongside their App.

As mention, Compound Promises are Promises that contain other Promises. That ability allows Platform teams to deliver entire stacks on demand, instead of simple databases or services.

### Configuring a Compound Promise

We are going to make Postgresql available to the App-as-a-Service Promise via an existing Postgresql promise.

#### Defining Promises via Dependencies

You've already been introduced to the concept of `Dependencies`, Promises can also be specified as Dependencies for a Promise. You can add the Postgresql Promise declared in [this file](https://raw.githubusercontent.com/syntasso/promise-postgresql/main/promise.yaml) to the existing `promise.yaml` for the App-as-a-Service. This means that it is treated like just another dependency for the Promise.

As mentioned, updating the `Dependencies` field for long specifications can be difficult to format correctly so the full updated promise can be found below

<details>
<summary>

_Click here_ for the updated `promise.yaml` file.

</summary>

```mdx-code-block
import FullPromise from "!!raw-loader!./_partials/writing-a-compound-promise/01-promise-with-postgres-dependency.yaml"
```

<CodeBlock language="yaml" title="app-promise/promise.yaml">
    {FullPromise}
</CodeBlock>

</details>

Since Compound Promise Dependencies are Promises, and considering that Kratix and its CRDs (Custom Resource Definitions) are only installed in the platform cluster, you need to ensure the Dependencies are applied exclusively to the platform cluster.

This is controlled by the `destinationSelectors` key:

```yaml
apiVersion: platform.kratix.io/v1alpha1
kind: Promise
metadata:
  name: app
spec:
    #highlight-start
    destinationSelectors:
    - matchLabels:
        environment: platform      
#highlight-end
    api:
...
```

The `destinationSelectors` are set to target clusters with matchLabel equal to `environment: platform`. In other words, that is telling Kratix to install the sub-Promises into Destinations with an `environment: platform` label.

You may have noticed that, when registering the Platform Destination, the Destination definition included exactly that label. You can verify the applied labels with:

```shell-session
$ kubectl --context $PLATFORM get destinations.platform.kratix.io --show-labels
NAME                 AGE    LABELS
#highlight-start
platform-cluster     1hr    environment=platform
#highlight-end
worker-1             1hr    environment=dev
```

However, the Postgresql Promise's Dependencies should not be installed in the platform cluster, but in the worker cluster. When [Installing Kratix](installing-kratix), you registered the worker cluster as a Destination with a label `environment: dev` (as per output above). The `destinationSelectors` field in the Postgresql Promise is set to target those clusters:

```yaml showLineNumbers
apiVersion: platform.kratix.io/v1alpha1
kind: Promise
metadata:
  name: app
spec:
  destinationSelectors:
    - matchLabels:
        environment: platform
  dependencies:
    - apiVersion: platform.kratix.io/v1alpha1
      kind: Promise
      metadata:
        name: postgres
      spec:
        #highlight-start
        destinationSelectors:
          - matchLabels:
              environment: dev
        #highlight-end
        dependencies:
        ... # remainder of the postgresql Promise ...
  ... # remainder of the app Promise...
```

#### Defining Promises as Required Promises

As you can see, defining an additional Promise as a dependency in the `promise.yaml` can make the Promise definition much longer, and make it harder to read. Instead of defining the Postgresql promise as a `Dependency`, it can instead be specified as a `requiredPromise`.

We know that it is not only users of the App-as-a-Service who will require the `postgres` and as result a result, it doesn't make sense for the Postgresql promise to be tied to the App-as-a-Service promise. You can instead deploy the Postgresql Promise on its own and ensure that the Postgresql Promise is installed when you install or update any Promise that will utilise it.

With `requiredPromises` you can specify the name and version of an existing Promise. Add the following to the `spec` of your `promise.yaml`. 

```yaml
  requiredPromises:
  - name: postgresql
    version: v1.0.0-beta.1
```

This states that the App-as-a-Promise needs the postgresql Promise to be installed at version `v1.0.0-beta.1`. You can read more about Promise versioning [in the reference documentation](releases).

Delete the previously configured `Dependencies` section from your `promise.yaml` and apply your newly updated promise.

```
kubectl --context $PLATFORM apply --filename promise.yaml
```

You should have observed a warning similar to the following:

```bash
Warning: Requirement Promise "postgresql" at version "v1.0.0-beta.1" not installed
Warning: Promise will not be available until the above issue(s) is resolved
```

This is because the Postgresql promise is no longer being installed by the App-as-a-Service which now _expects_ the Postgresql Promise to exist already. So let's fix that, run the following to install the Postgresql Promise:

```bash
kubectl --context $PLATFORM apply --filename https://raw.githubusercontent.com/syntasso/promise-postgresql/main/promise-release.yaml
```

::info
You might have noticed that the above command uses a Promise Release to install the Postgresql Promise, we will not be exploring this in depth but you can look at the [documentation](releases) for more information
:::

### Updating the Pipelines

So now you have an App-as-a-Service Promise that requires a Postgresql Promise but does not yet do anything with it. 

We'll need to define an additional step in the pipeline that makes a request for a Postgresql service when making or updating a request for an app. We'll start by defining the pipeline stage that will run when a user wants the request a Postgresql service with their app.

Create a `database-configure` file in the `workflows` , make it executable and copy the contents of [this file](https://gist.github.com/syntassodev/7cfae7b53bc54615cf351760a8377ba2) into it.

```bash
touch workflows/database-configure
chmod +x workflows/database-configure
curl -o workflows/database-configure --silent https://gist.github.com/syntassodev/7cfae7b53bc54615cf351760a8377ba2
```

Lets take a closer look at the script. Unlike the Ingress configured via the NGINX Controller, we will not always want to provision a Postgresql service with each app. The script will only provision a Postgresql if the resource request `spec` specifies a `dbDriver` key a value of `postgresql`:

```ruby
if dbDriver != 'postgresql' then
  puts "Unsupported db driver: #{dbDriver}"
  puts "Supported drivers: postgresql"
  exit 1
end
```

It then creates a Resource Request for the Postgresql promise:

```ruby
postgresqlRequest = {
  'apiVersion' => "marketplace.kratix.io/v1alpha1",
  'kind' => 'postgresql',
  'metadata' => {
    'name' => "#{dbName}",
    'namespace' => "#{namespace}"
  },
  'spec' => {
    'teamId' => "#{teamId}",
    'dbName' => "#{dbName}"
  }
}
```

As the the contents of `/kratix/output/platform` need to go to the Platform cluster, it explicitly states that the output needs to be directed to the Platform:

```ruby
destinationSelectorsRequest = [{
  'directory' => 'platform',
  'matchLabels' => {
    'environment' => 'platform'
  }
}]
```

It then updates the app deployment with the details of the database:

```ruby
env = [{
  'name' => 'PGPASSWORD',
  'valueFrom' => {
    'secretKeyRef' => {
      'name' => "#{secretRef}",
      'key' => 'password'
      },
    }
  }, {
    'name' => 'PGUSER',
    'valueFrom' => {
      'secretKeyRef' => {
        'name' => "#{secretRef}",
        'key' => 'username'
      },
    }
  }, {
    'name' => 'PGHOST',
    'value' => "#{teamId}-#{dbName}-postgresql.default.svc.cluster.local"
  }, {
    'name' => 'DBNAME',
    'value' => "#{dbName}"
  }
]

# Injecting the database credentials into the app deployment
existingDeployment = YAML.load_file('/kratix/output/deployment.yaml')
existingDeployment['spec']['template']['spec']['containers'][0]['env'] = env
```

Now that the script has been defined, we can test it by running the `resource-configure` workflow followed by the `database-configure` workflow. But first, we need to update the `spec` of the `object.yaml` to include `dbDriver: postgresql`.

Update the workflows `Dockerfile` to add the new `database-configure` script:

```dockerfile
COPY database-configure database-configure
```

And now you can use the `test-pipeline` script to test the workflows by running the following:

```bash
./scripts/test-pipeline "resource-configure && database-configure"
```

You should now see the details of the newly provisioned Postgresql in the `spec` of your `outputs/deployment.yaml`, it will look similar to this:

```bash
env:
- name: PGPASSWORD
    valueFrom:
    secretKeyRef:
        name: my-app-team.my-app-team-my-app-db-postgresql.credentials.postgresql.acid.zalan.do
        key: password
- name: PGUSER
    valueFrom:
    secretKeyRef:
        name: my-app-team.my-app-team-my-app-db-postgresql.credentials.postgresql.acid.zalan.do
        key: password
- name: PGHOST
    value: my-app-team-my-app-db-postgresql.default.svc.cluster.local
- name: DBNAME
    value: my-app-db
```

And now for the final step, updating your App-as-a-Service specification. Update your `promise.yaml` to add the `database-configure` step to the `spec.workflows.resource.configure` list:

```
- apiVersion: platform.kratix.io/v1alpha1
    kind: Pipeline
    metadata:
    name: database-configure
    spec:
    containers:
        - name: database-configure
        image: kratix-workshop/create-resources:v1.0.0
        command: [ database-configure ]
```

As the `dbDriver` is a new field on the Promise that will be exposed to users, we need to add this to the CRD of the Promise. In your `promise.yaml`, update the existing `schema` of `v1` of the CRD with the following:

```yaml
schema:
openAPIV3Schema:
    type: object
    properties:
    spec:
        type: object
        properties:
        service:
            type: object
            properties:
            port:
                type: integer
        image:
            type: string
#highlight-start
        dbDriver:
            type: string
#highlight-end
```

You are now ready to apply your Promise again.

```bash
kubectl --context $PLATFORM apply --filename promise.yaml
```

Before applying the Resource Request again, you'll need to update it to add the `dbDriver` field to the `spec`.

```yaml
spec:
  image: example/image:v1.0.0
  dbDriver: postgresql
  service:
    port: 9000
```

You can now apply your updated App-as-a-Service Resource Request:

```bash
kubectl --context $PLATFORM apply --filename resource-request.yaml
```

You can validate your updates by running the following:

```bash
kubectl --context $WORKER get postgresql
```

## üéâ Congratulations

‚úÖ &nbsp; You have just created your first Compound Promise. <br />
üëâ &nbsp; You can go check [what's next](whats-next) to learn about what else you can achieve with Kratix.
